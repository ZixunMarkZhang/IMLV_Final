---
title: "Bank Marketing Analysis"
author: "Zixun Zhang"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
---
```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```

# Proposal

1.  Data

The data set in this project is the [Bank Marketing Data Set](https://archive.ics.uci.edu/ml/datasets/Bank+Marketing) from UC Irvine Machine Learning Repository. It contains the costumer of bank client. The feature contains as follows:

1 - age (numeric)\
2 - job : type of job (categorical: 'admin.','blue-collar','entrepreneur','housemaid','management','retired','self-employed','services','student','technician','unemployed','unknown')\
3 - marital : marital status (categorical: 'divorced','married','single','unknown'; note: 'divorced' means divorced or widowed)\
4 - education (categorical: 'basic.4y','basic.6y','basic.9y','high.school','illiterate','professional.course','university.degree','unknown')\
5 - default: has credit in default? (categorical: 'no','yes','unknown')\
6 - housing: has housing loan? (categorical: 'no','yes','unknown')\
7 - loan: has personal loan? (categorical: 'no','yes','unknown')\
\# related with the last contact of the current campaign:\
8 - contact: contact communication type (categorical: 'cellular','telephone')\
9 - month: last contact month of year (categorical: 'jan', 'feb', 'mar', \..., 'nov', 'dec')\
10 - day_of_week: last contact day of the week (categorical: 'mon','tue','wed','thu','fri')\
11 - duration: last contact duration, in seconds (numeric). Important note: this attribute highly affects the output target (e.g., if duration=0 then y='no'). Yet, the duration is not known before a call is performed. Also, after the end of the call y is obviously known. Thus, this input should only be included for benchmark purposes and should be discarded if the intention is to have a realistic predictive model.\
\# other attributes:\
12 - campaign: number of contacts performed during this campaign and for this client (numeric, includes last contact)\
13 - pdays: number of days that passed by after the client was last contacted from a previous campaign (numeric; 999 means client was not previously contacted)\
14 - previous: number of contacts performed before this campaign and for this client (numeric)\
15 - poutcome: outcome of the previous marketing campaign (categorical: 'failure','nonexistent','success')\
\# social and economic context attributes\
16 - emp.var.rate: employment variation rate - quarterly indicator (numeric)\
17 - cons.price.idx: consumer price index - monthly indicator (numeric)\
18 - cons.conf.idx: consumer confidence index - monthly indicator (numeric)\
19 - euribor3m: euribor 3 month rate - daily indicator (numeric)\
20 - nr.employed: number of employees - quarterly indicator (numeric)

The label of this data set to predict is a binary variable whether the customer subscribed a term deposit.

The features will be preprocessed at the beginning of the project. The categorical data will be encoded by one hot encoder. The numerical data will be normalized if it significantly different mean and standard deviation.

2.  Modeling Goal

Generate a predictive model by which we get specific information of a client and predict if the client subscribed a term deposit. In real world context, this helps the banks to identify the potential client of term deposit service when they utilize the model on customer information.

3.  Methodology

Various classification methods will be deployed in this projects including logistic regression, decision tree, and random forest. The introduction of each model are shown as follow:

3.1 Logistic regression

Logistic regression is a linear classification model where the log odd is predicted by a linear function with the features. Feature selection according to importance and conduct hypothesis test on coefficient are necessary as there might be feature which has minor effect on the labels.

3.2 Decision Tree

Decision tree will build a model where the nodes splits by calculating the cutoff with minimum the gini index, and the tree stops generating at gini index reaches 0 at each nodes. After the tree is built, we may access it to make classification predictions. Even if overfitting is likely to happen, we may address this by prune the tree.

3.3 Random Forest

Random forest is a model where the classification decision is made according to most common decision tree result in a number of random generated decision trees. This model is also likely to have overfitting. Hyperparameter tuning will be deployed to ensure there is no overfitting.

After the models are built, the optimal thresholds will be selected for each model according to context requirement such as high specificity or high sensitivity.

The evaluation of the models is not only seeking for accuracy but also interpretability. Visualization tools such as confusion matrix, ROC curve, and feature importance plot will be deployed in the project to ensure the models are understandable and reproducible. At the end of this project, the model selection will be based on not only numerical metrics such as accuracy or loss but also visualized metrics such as feature importance plot and ROC curve to ensure interpretability, acceptable model complexity, and preciseness.

Citation

1.  [Moro et al., 2014] S. Moro, P. Cortez and P. Rita. A Data-Driven Approach to Predict the Success of Bank Telemarketing. Decision Support Systems, Elsevier, 62:22-31, June 2014, <https://archive.ics.uci.edu/ml/datasets/Bank+Marketing>

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# [EDA]
```{r}
library(ggplot2)
#data cleaning
bankfull <- read.csv("bank-additional-full.csv", sep=";")
#delete month and data of week as they are irrelevant. Eliminate duration as it has extremely high correlation with target
bankfull = subset(bankfull, select = -c(month,day_of_week,duration) )
#delete all rows with unknown values
bankfull<-subset(bankfull, (job!='unknown') & (marital!='unknown') & (education!='unknown')&
                   (default!='unknown')& (housing!='unknown')&(loan!='unknown'))
ggplot(bankfull, aes(x = y)) +
  geom_bar()
```
```{r}
numrical  = bank[,c('age','campaign','pdays','previous','emp.var.rate','cons.price.idx','cons.conf.idx','euribor3m','nr.employed')]
res = cor(numrical)
library(corrplot)
corrplot(res, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)
```
```{r}
bankfull = subset(bankfull, select = -c(nr.employed,emp) )
```

1 - age (numeric)\
```{r}
ggplot(bankfull,aes(x=scale(age),fill=y))+
  geom_histogram()+
  scale_fill_brewer(palette = 'Set3')
```

2 - job : type of job (categorical: 'admin.','blue-collar','entrepreneur','housemaid','management','retired','self-employed','services','student','technician','unemployed','unknown')\
```{r}
ggplot(data = bankfull, aes(y = job, fill = y)) +
  geom_bar(position="dodge")+
  scale_fill_brewer(palette = 'Set3')
```

3 - marital : marital status (categorical: 'divorced','married','single','unknown'; note: 'divorced' means divorced or widowed)\
```{r}
ggplot(data = bankfull, aes(y = marital, fill = y)) +
  geom_bar(position="dodge")+
  scale_fill_brewer(palette = 'Set3')
```

4 - education (categorical: 'basic.4y','basic.6y','basic.9y','high.school','illiterate','professional.course','university.degree','unknown')\
```{r}
ggplot(data = bankfull, aes(y = education, fill = y)) +
  geom_bar(position="dodge")+
  scale_fill_brewer(palette = 'Set3')
```

5 - default: has credit in default? (categorical: 'no','yes','unknown')\
```{r}
ggplot(data = bankfull, aes(y = default, fill = y)) +
  geom_bar(position="dodge")+
  scale_fill_brewer(palette = 'Set3')
```

6 - housing: has housing loan? (categorical: 'no','yes','unknown')\
```{r}
ggplot(data = bankfull, aes(y = housing, fill = y)) +
  geom_bar(position="dodge")+
  scale_fill_brewer(palette = 'Set3')
```
7 - loan: has personal loan? (categorical: 'no','yes','unknown')\
```{r}
ggplot(data = bankfull, aes(y = loan, fill = y)) +
  geom_bar(position="dodge")+
  scale_fill_brewer(palette = 'Set3')
```
\# related with the last contact of the current campaign:\
8 - contact: contact communication type (categorical: 'cellular','telephone')\
```{r}
ggplot(data = bankfull, aes(y = contact, fill = y)) +
  geom_bar(position="dodge")+
  scale_fill_brewer(palette = 'Set3')
```
\# other attributes:\
12 - campaign: number of contacts performed during this campaign and for this client (numeric, includes last contact)\
```{r}
ggplot(bankfull,aes(x=scale(campaign),fill=y))+
  geom_histogram()+
  scale_fill_brewer(palette = 'Set3')
```
13 - pdays: number of days that passed by after the client was last contacted from a previous campaign (numeric; 999 means client was not previously contacted)\
```{r}
ggplot(subset(bankfull,pdays!=999),aes(x=scale(pdays),fill=y))+
  geom_histogram()+
  scale_fill_brewer(palette = 'Set3')
```
14 - previous: number of contacts performed before this campaign and for this client (numeric)\
```{r}
ggplot(bankfull,aes(x=scale(age),fill=y))+
  geom_histogram()+
  scale_fill_brewer(palette = 'Set3')
```
15 - poutcome: outcome of the previous marketing campaign (categorical: 'failure','nonexistent','success')\
```{r}
ggplot(data = bankfull, aes(y = poutcome, fill = y)) +
  geom_bar(position="dodge")+
  scale_fill_brewer(palette = 'Set3')
```
\# social and economic context attributes\

17 - cons.price.idx: consumer price index - monthly indicator (numeric)\
```{r}
ggplot(bankfull,aes(x=scale(cons.price.idx),fill=y))+
  geom_histogram()+
  scale_fill_brewer(palette = 'Set3')
```
18 - cons.conf.idx: consumer confidence index - monthly indicator (numeric)\
```{r}
ggplot(bankfull,aes(x=scale(cons.conf.idx),fill=y))+
  geom_histogram()+
  scale_fill_brewer(palette = 'Set3')
```
19 - euribor3m: euribor 3 month rate - daily indicator (numeric)\
```{r}
ggplot(bankfull,aes(x=scale(euribor3m),fill=y))+
  geom_histogram()+
  scale_fill_brewer(palette = 'Set3')
```




```{r}
#keep binary variables
bank = subset(bankfull,select = c(marital, default, housing, loan,contact))
#process numerical values
bank$age = c(scale(bankfull$age))
bank$campaign = c(scale(bankfull$campaign))
bank$pdays =c(scale(bankfull$pdays))
bank$previous =c(scale(bankfull$previous))
bank$cons.price.idx =c(scale(bankfull$cons.price.idx))
bank$cons.conf.idx =c(scale(bankfull$cons.conf.idx))
bank$euribor3m =c(scale(bankfull$euribor3m))
bank$y = as.factor((bankfull$y=='yes'))
library(caret)

dummy <- dummyVars(" ~ .", subset(bankfull, select = c(education,job,poutcome)))
df <- data.frame(predict(dummy, newdata = subset(bankfull, select = c(education,job,poutcome)))) 
bank = cbind(df,bank)
set.seed(5293)
n <- nrow(df)
train <- sample(n, .7*n)
train_dat <-bank[train, ]
test_dat<- bank[-train,]
```

<!--chapter:end:EDA.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# [Logistic Regression]


```{r message=FALSE, warning=FALSE}
#build Logistic regression model
fullmod<-glm(y~.,data=train_dat,family=binomial(link = 'logit'))
LRpred = predict(fullmod,test_dat,type = 'response')
```

```{r message=FALSE, warning=FALSE}
library(caret)
library(reshape2)
library(tibble)
library(ggplot2)
library(tidyverse)
library(fastshap)
pred <- function(model, newdata) {
  predict(model, newdata = newdata, type = "terms")
}
shap_values <- fastshap::explain(
  fullmod, 
  X = train_dat,           
  feature_names = colnames(train_dat |> dplyr::select(-y)),
  pred_wrapper = pred, 
  nsim = 5,
  newdata = test_dat
)

ggplot(melt(shap_values),aes(value, reorder(variable, value, FUN = median)))+
  geom_boxplot()
```
```{r}
library(pdp)
pdp_hit_rf = partial(fullmod,pred.var = 'cons.price.idx')
g <- ggplot(pdp_hit_rf, aes(cons.price.idx, yhat)) +
  geom_line() +
  geom_rug(data = train_dat, aes(cons.price.idx), inherit.aes = FALSE, alpha = .5,
  color = "red") +
  theme_bw(16)
g+ylab('prob')
```

    After the logistic regression models are built, we may access the feature importance by visualize the coefficient. The bar plot above shows the magnitude of significance for each variable with a descending order of their absolute value. It is obvious that the default value has the largest influence on the predicted probability. However, that's mostly because of the default yes record in the data set according to the EDA part. Despite the default values, whether the person is illiterate, employment variable rate, whether the contacting is via telephone, and the outcome of previous campaign has remarkable impact on the prediction. However, the coefficient of default is too large that we actually can not assess the exact coefficient of variables by visualization; hence we may eliminate the default from the graph and get a new bar plot as follows.

```{r}
get_rates <- function(threshold, actual, response) {
  predicted <- ifelse(response < threshold, 0, 1)
  
  TP <- sum(actual == 1 & predicted == 1)
  FP <- sum(actual == 0 & predicted == 1)
  TN <- sum(actual == 0 & predicted == 0)
  FN <- sum(actual == 1 & predicted == 0)
  
  tpr <- TP/(TP + FN)
  fpr <- FP/(TN + FP)  
  
  data.frame(threshold, tpr, fpr)
  
}


rocdf <- map_df(seq(0, 1, .01), get_rates, test_dat$y==TRUE, LRpred)
rocdf <- rocdf |> 
  mutate(label = ifelse(threshold %in% seq(0, 1, .01),
                        threshold, NA))
library(ggrepel)
g <- ggplot(rocdf, aes(x = fpr, y = tpr, label = label)) +
  geom_point() +
  geom_path() +
  geom_label_repel(color = "blue", size = 2)
plotly::ggplotly(g)
```

<!--chapter:end:model1.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# [Decision Tree]
```{r}
library(rpart)
DTmod <- rpart(y ~ ., data = train_dat,cp=0,method='class')
pred <- function(model, newdata) {
  predict(model, newdata = newdata, type = "prob")[, 2]
}
plotcp(DTmod)
```
```{r}
DTmod <- rpart(y ~ ., data = train_dat,cp=0.002,method='class')

DTpred = predict(DTmod,test_dat)[,2]
```


```{r}

shap_values <- fastshap::explain(
  DTmod, 
  X = train_dat,           
  feature_names = colnames(train_dat |> dplyr::select(-y)),
  pred_wrapper = pred, 
  nsim = 5,
  newdata = test_dat
)

library(ggplot2)
library(reshape2)
ggplot(melt(shap_values),aes(value, reorder(variable, value, FUN = median)))+
  geom_boxplot()
```


```{r}
get_rates <- function(threshold, actual, response) {
  predicted <- ifelse(response < threshold, 0, 1)
  
  TP <- sum(actual == 1 & predicted == 1)
  FP <- sum(actual == 0 & predicted == 1)
  TN <- sum(actual == 0 & predicted == 0)
  FN <- sum(actual == 1 & predicted == 0)
  
  tpr <- TP/(TP + FN)
  fpr <- FP/(TN + FP)  
  
  data.frame(threshold, tpr, fpr)
  
}


rocdf <- map_df(seq(0, 1, .01), get_rates, test_dat$y==TRUE, DTpred)
rocdf <- rocdf |> 
  mutate(label = ifelse(threshold %in% seq(0, 1, .01),
                        threshold, NA))
library(ggrepel)
g <- ggplot(rocdf, aes(x = fpr, y = tpr, label = label)) +
  geom_point() +
  geom_path() +
  geom_label_repel(color = "blue", size = 2)
plotly::ggplotly(g)
```

<!--chapter:end:model2.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# [Random Forest]
```{r}
library(randomForest)
RFmod <- randomForest(y ~ ., data = train_dat)
pred <- function(model, newdata) {
  predict(model, newdata = newdata, type = "prob")[, 2]
}
RFpred = predict(RFmod,test_dat,type = 'prob')[,2]
```

```{r}
shap_values <- fastshap::explain(
  RFmod, 
  X = train_dat,           
  feature_names = colnames(train_dat |> dplyr::select(-y)),
  pred_wrapper = pred, 
  nsim = 5,
  newdata = test_dat
)
ggplot(melt(shap_values),aes(value, variable))+
  geom_boxplot()
```


```{r}
get_rates <- function(threshold, actual, response) {
  predicted <- ifelse(response < threshold, 0, 1)
  
  TP <- sum(actual == 1 & predicted == 1)
  FP <- sum(actual == 0 & predicted == 1)
  TN <- sum(actual == 0 & predicted == 0)
  FN <- sum(actual == 1 & predicted == 0)
  
  tpr <- TP/(TP + FN)
  fpr <- FP/(TN + FP)  
  
  data.frame(threshold, tpr, fpr)
  
}


rocdf <- map_df(seq(0, 1, .01), get_rates, test_dat$y==TRUE, RFpred)
rocdf <- rocdf |> 
  mutate(label = ifelse(threshold %in% seq(0, 1, .01),
                        threshold, NA))
library(ggrepel)
g <- ggplot(rocdf, aes(x = fpr, y = tpr, label = label)) +
  geom_point() +
  geom_path() +
  geom_label_repel(color = "blue", size = 2)
plotly::ggplotly(g)
```

<!--chapter:end:model3.Rmd-->

```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
```
# Reflections


<!--chapter:end:reflections.Rmd-->

