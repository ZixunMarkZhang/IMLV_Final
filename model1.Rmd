# [Logistic Regression]


```{r message=FALSE, warning=FALSE}
#build Logistic regression model
fullmod<-glm(y~.,data=train_dat,family=binomial(link = 'logit'))
LRpred = predict(fullmod,test_dat,type = 'response')
```

```{r message=FALSE, warning=FALSE}
library(caret)
library(reshape2)
library(tibble)
library(ggplot2)
library(tidyverse)
library(fastshap)
pred <- function(model, newdata) {
  predict(model, newdata = newdata, type = "terms")
}
shap_values <- fastshap::explain(
  fullmod, 
  X = train_dat,           
  feature_names = colnames(train_dat |> dplyr::select(-y)),
  pred_wrapper = pred, 
  nsim = 5,
  newdata = test_dat
)

ggplot(melt(shap_values),aes(value, reorder(variable, value, FUN = median)))+
  geom_boxplot()
```
```{r}
library(pdp)
pdp_hit_rf = partial(fullmod,pred.var = 'cons.price.idx')
g <- ggplot(pdp_hit_rf, aes(cons.price.idx, yhat)) +
  geom_line() +
  geom_rug(data = train_dat, aes(cons.price.idx), inherit.aes = FALSE, alpha = .5,
  color = "red") +
  theme_bw(16)
g+ylab('prob')
```

    After the logistic regression models are built, we may access the feature importance by visualize the coefficient. The bar plot above shows the magnitude of significance for each variable with a descending order of their absolute value. It is obvious that the default value has the largest influence on the predicted probability. However, that's mostly because of the default yes record in the data set according to the EDA part. Despite the default values, whether the person is illiterate, employment variable rate, whether the contacting is via telephone, and the outcome of previous campaign has remarkable impact on the prediction. However, the coefficient of default is too large that we actually can not assess the exact coefficient of variables by visualization; hence we may eliminate the default from the graph and get a new bar plot as follows.

```{r}
get_rates <- function(threshold, actual, response) {
  predicted <- ifelse(response < threshold, 0, 1)
  
  TP <- sum(actual == 1 & predicted == 1)
  FP <- sum(actual == 0 & predicted == 1)
  TN <- sum(actual == 0 & predicted == 0)
  FN <- sum(actual == 1 & predicted == 0)
  
  tpr <- TP/(TP + FN)
  fpr <- FP/(TN + FP)  
  
  data.frame(threshold, tpr, fpr)
  
}


rocdf <- map_df(seq(0, 1, .01), get_rates, test_dat$y==TRUE, LRpred)
rocdf <- rocdf |> 
  mutate(label = ifelse(threshold %in% seq(0, 1, .01),
                        threshold, NA))
library(ggrepel)
g <- ggplot(rocdf, aes(x = fpr, y = tpr, label = label)) +
  geom_point() +
  geom_path() +
  geom_label_repel(color = "blue", size = 2)
plotly::ggplotly(g)
```
